<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ü™ô Pi Tic Tac Toe - AI + 1 Pi Payments (Undo & Exclusive LB)</title>

    <script src="https://sdk.minepi.com/pi-sdk.js"></script>

    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>

    <script> /* Example Pi init for sandbox/testing */ Pi && Pi.init && Pi.init({ version: "2.0", sandbox: true }); </script>

    <style>
        :root { --n: 3; }
        html,body { height: 100%; }
        body {
            font-family: Arial, Helvetica, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
            color: white;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
        }

        #game-setup,#wallet-section,#stats-section {
            background: rgba(255,255,255,0.08);
            padding: 18px;
            border-radius: 14px;
            backdrop-filter: blur(8px);
            margin-bottom: 16px;
            text-align: center;
            width: 90%;
            max-width: 420px;
        }

        #mode-select {
            padding: 10px 14px;
            font-size: 16px;
            border: none;
            border-radius: 22px;
            background: rgba(255,255,255,0.95);
            color: #222;
            margin-top: 8px;
            width: 100%;
        }

        #status { font-size: 20px; margin: 8px 0 12px; color: #fff; min-height: 34px; text-shadow: 0 2px 4px rgba(0,0,0,0.25); }

        #board {
            display: grid;
            grid-template-columns: repeat(var(--n), 1fr);
            gap: 8px;
            max-width: min(90vw, 520px);
            aspect-ratio: 1/1;
            margin: 8px auto 18px;
            width: 100%;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.95);
            border-radius: 12px;
            font-size: clamp(24px, 8vw, 72px);
            font-weight: 700;
            display:flex;
            align-items:center;
            justify-content:center;
            cursor:pointer;
            user-select:none;
            transition: transform .12s ease, box-shadow .12s ease;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            color: #222;
        }

        .cell:hover:not(.ai-thinking):not(.disabled) { transform: scale(1.03); }

        .cell.x { color: #c0392b; }
        .cell.o { color: #2980b9; }

        .cell.won { background: #2ecc71 !important; color: #fff; animation: pulse .45s linear; }
        @keyframes pulse { 0%{transform:scale(1)}50%{transform:scale(1.06)}100%{transform:scale(1)} }

        .ai-thinking, .disabled { cursor: wait !important; opacity: 0.7; }

        #controls { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; max-width:520px; width:100%; }

        button {
            padding: 10px 16px;
            font-size: 15px;
            cursor:pointer;
            border:none;
            border-radius: 18px;
            color: white;
            transition: transform .12s ease, box-shadow .12s ease;
            min-width: 140px;
        }

        buttong { 
            padding: 10px 16px;
            font-size: 15px;
            cursor:pointer;
            border:none;
            border-radius: 18px;
            color: rgb(15, 221, 77);
            transition: transform .12s ease, box-shadow .12s ease;
            min-width: 140px;
        }
        button:hover:not(:disabled){ transform: translateY(-3px); box-shadow:0 6px 18px rgba(0,0,0,0.18); }
        button:disabled { opacity: .55; cursor:not-allowed; transform:none; box-shadow:none; }

        #connect-btn { background: linear-gradient(45deg,#667eea,#764ba2); }
        #undo-btn,#submit-btn { background: linear-gradient(45deg,#f39c12,#e67e22); }
        #lb-btn { background: linear-gradient(45deg,#2ecc71,#27ae60); width:100%; max-width: 220px; }

        #address, #personal-stats { margin-top:8px; font-family: monospace; font-size:13px; word-break:break-all; color:#ecf0f1; }

        /* leaderbord modal */
        #leaderboard-section { display:none; position:fixed; inset:0; z-index:999; align-items:center; justify-content:center; background: rgba(0,0,0,0.5); }
        #lb-content { background: rgba(255,255,255,0.97); color:#222; padding:22px; border-radius:14px; max-width:92vw; max-height:84vh; overflow:auto; }
        #lb-table { width:100%; border-collapse:collapse; margin-top:12px; }
        #lb-table th, #lb-table td { padding:10px; text-align:left; border-bottom:1px solid #ddd; font-size:14px; }
        #lb-table th { background:#667eea; color:white; position:sticky; top:0; }
        .close-lb { background:#e74c3c; color:white; border:none; padding:8px 12px; border-radius:8px; float:right; cursor:pointer; }
    </style>
</head>
<body>
    <h1 style="font-size:26px;margin:6px 0;">ü™ô Pi Tic Tac Toe + ü§ñ AI + üí∞ Paid Features</h1>
    <p style="text-align:center;max-width:420px;opacity:.92;margin:6px 0 12px;">Undo mistakes (1 Pi), Submit paid wins to Exclusive LB (1 Pi), optional ad-free gameplay when running through Pi Browser.</p>

    <div id="game-setup">
        <label for="mode-select" style="display:block;font-size:15px;">Game Mode</label>
        <select id="mode-select" aria-label="Game mode selector">
            <option value="hotseat">üë´ Play with Friend (3√ó3)</option>
            <option value="easy">ü§ñ AI - Easy (3√ó3)</option>
            <option value="mid">ü§ñ AI - Medium (3√ó3)</option>
            <option value="hard">ü§ñ AI - Hard (3√ó3)</option>
            <option value="unbeatable">ü§ñ AI - Unbeatable (5√ó5)</option>
        </select>
    </div>

    <div id="wallet-section">
        <button id="connect-btn" type="button">Connect Pi Account</button>
        <div id="address" aria-live="polite"></div>
    </div>

    <div id="stats-section" style="display:none;">
        <div id="personal-stats">Connect to see your stats!</div>
    </div>

    <div id="status" role="status">Player X's Turn</div>

    <div id="board" aria-label="Tic Tac Toe board"></div>

    <div id="controls">
        <button id="undo-btn" style="display:none;">Undo Last Move - 1 Pi</button>
        <button id="submit-btn" style="display:none;">Submit Win to Exclusive LB - 1 Pi</button>
        <buttong id="reset-btn">New Game</buttong>
        <button id="lb-btn">üèÜ View Leaderboard</button>
    </div>

    <div id="leaderboard-section" role="dialog" aria-modal="true">
        <div id="lb-content">
            <button class="close-lb" onclick="document.getElementById('leaderboard-section').style.display='none'">‚úñ</button>
            <h2 style="margin-top:6px;">üèÜ Exclusive Pi LB (Paid Wins)</h2>
            <p style="font-size:13px; opacity:.8;">Top players (by total paid-win score)</p>
            <table id="lb-table" aria-label="Leaderboard">
                <thead><tr><th>Rank</th><th>@Player</th><th>Score</th></tr></thead>
                <tbody></tbody>
            </table>
            <p style="font-size:12px;opacity:.7;">Submit only after a legitimate victory ‚Äî leaderboard uses server-side timestamps from Firebase.</p>
        </div>
    </div>

    <p style="margin-top:18px;font-size:12px;opacity:.75;">Minimax AI + Firebase RTDB leaderboard. Use Pi Browser for payments/auth integration.</p>

    <script>
        // ===== FIREBASE CONFIG (replace with your project's values) =====
        const firebaseConfig = {
          apiKey: "2Uf26vH9DDFchSE41LbBuO0dHx0CqMB1kdKP00qN",
          authDomain: "pi-tictactoe-leaderboard.firebaseapp.com",
          databaseURL: "https://pi-tictactoe-leaderboard-default-rtdb.firebaseio.com",
          projectId: "pi-tictactoe-leaderboard",
          storageBucket: "pi-tictactoe-leaderboard.appspot.com",
          messagingSenderId: "1234567890",
          appId: "1:1234567890:web:abcdef1234567890"
        };

        let db = null;
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.database();
        } catch (e) {
            console.warn('Firebase not initialized (check config). Leaderboard disabled until configured.', e);
        }

        // ===== Game state =====
        let N = 3;
        let boardSize = 9;
        let board = [];
        let winningConditions = [];
        let currentPlayer = 'X';
        let gameActive = true;
        let piUser = null;
        let gameMode = 'hotseat';
        const humanPlayer = 'X';
        const aiPlayer = 'O';
        let history = []; // list of {index, player}
        let aiTimeoutId = null;
        let statsKey = null;

        const mistakeProbs = { easy: 0.65, mid: 0.35, hard: 0.08, unbeatable: 0.00 };
        const scoreValues = { easy: 1, mid: 3, hard: 5, unbeatable: 20 };

        const statusDiv = document.getElementById('status');
        const boardDiv = document.getElementById('board');
        const connectBtn = document.getElementById('connect-btn');
        const addressDiv = document.getElementById('address');
        const resetBtn = document.getElementById('reset-btn');
        const modeSelect = document.getElementById('mode-select');
        const undoBtn = document.getElementById('undo-btn');
        const submitBtn = document.getElementById('submit-btn');
        const lbBtn = document.getElementById('lb-btn');
        const statsSection = document.getElementById('stats-section');
        const personalStatsDiv = document.getElementById('personal-stats');
        const lbSection = document.getElementById('leaderboard-section');

        // ===== Helpers =====
        function generateWinningConditions(n) {
            const wins = [];
            // rows
            for (let r = 0; r < n; r++) {
                const row = [];
                for (let c = 0; c < n; c++) row.push(r * n + c);
                wins.push(row);
            }
            // cols
            for (let c = 0; c < n; c++) {
                const col = [];
                for (let r = 0; r < n; r++) col.push(r * n + c);
                wins.push(col);
            }
            // main diagonal
            const diag1 = [];
            for (let i = 0; i < n; i++) diag1.push(i * n + i);
            wins.push(diag1);
            // anti diagonal
            const diag2 = [];
            for (let i = 0; i < n; i++) diag2.push(i * n + (n - 1 - i));
            wins.push(diag2);
            return wins;
        }

        function checkWinner(boardState) {
            for (let cond of winningConditions) {
                const first = boardState[cond[0]];
                if (first && cond.every(i => boardState[i] === first)) return first;
            }
            return null;
        }

        function isBoardFull(boardState) {
            return boardState.every(cell => cell != null);
        }

        function evaluate(boardState, aiPlyr) {
            const opp = humanPlayer;
            let score = 0;
            // center bonus for odd boards
            if (boardSize % 2 === 1) {
                const centerIdx = Math.floor(boardSize / 2);
                if (boardState[centerIdx] === aiPlyr) score += 10;
                else if (boardState[centerIdx] === opp) score -= 10;
            }
            const aiCount = boardState.filter(c => c === aiPlyr).length;
            const oppCount = boardState.filter(c => c === opp).length;
            score += (aiCount - oppCount) * 3;
            return score;
        }

        // Minimax with alpha-beta
        function minimax(newBoard, depth, isMaximizing, alpha, beta, aiPlyr, maxDepth) {
            const result = checkWinner(newBoard);
            if (result === aiPlyr) return 100 - depth;
            if (result === humanPlayer) return depth - 100;
            if (isBoardFull(newBoard)) return 0;
            if (depth >= maxDepth) return evaluate(newBoard, aiPlyr);

            const emptySpots = [];
            for (let i = 0; i < boardSize; i++) if (newBoard[i] === null) emptySpots.push(i);

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let i of emptySpots) {
                    newBoard[i] = aiPlyr;
                    const evalScore = minimax(newBoard, depth + 1, false, alpha, beta, aiPlyr, maxDepth);
                    newBoard[i] = null;
                    if (evalScore > maxEval) maxEval = evalScore;
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let i of emptySpots) {
                    newBoard[i] = humanPlayer;
                    const evalScore = minimax(newBoard, depth + 1, true, alpha, beta, aiPlyr, maxDepth);
                    newBoard[i] = null;
                    if (evalScore < minEval) minEval = evalScore;
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getBestMove(tempBoard, aiPlyr, maxDepth) {
            let bestScore = -Infinity;
            let bestMove = -1;
            for (let i = 0; i < boardSize; i++) {
                if (tempBoard[i] === null) {
                    tempBoard[i] = aiPlyr;
                    const score = minimax(tempBoard, 0, false, -Infinity, Infinity, aiPlyr, maxDepth);
                    tempBoard[i] = null;
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = i;
                    }
                }
            }
            return bestMove;
        }

        // ===== AI move =====
        function aiMove() {
            if (!gameActive) return;
            const prefix = piUser ? `@${piUser} - ` : '';
            statusDiv.textContent = prefix + 'ü§ñ AI Thinking...';
            boardDiv.querySelectorAll('.cell').forEach(cell => cell.classList.add('ai-thinking'));

            const emptySpots = [];
            for (let i = 0; i < boardSize; i++) if (board[i] === null) emptySpots.push(i);
            if (emptySpots.length === 0) return;

            let moveIndex = -1;
            const difficulty = gameMode;
            const maxDepth = (N === 3) ? 9 : 6; // sensible depth caps
            const mistakeChance = mistakeProbs[difficulty] || 0;

            if (Math.random() < mistakeChance) {
                moveIndex = emptySpots[Math.floor(Math.random() * emptySpots.length)];
            } else {
                moveIndex = getBestMove(board.slice(), aiPlayer, maxDepth);
                if (moveIndex === -1) moveIndex = emptySpots[Math.floor(Math.random() * emptySpots.length)];
            }

            setTimeout(() => {
                if (!gameActive) return;
                board[moveIndex] = aiPlayer;
                const cell = document.querySelector(`[data-index="${moveIndex}"]`);
                if (cell) {
                    cell.textContent = aiPlayer;
                    cell.classList.add(aiPlayer.toLowerCase());
                }
                history.push({ index: moveIndex, player: aiPlayer });

                const winner = checkWinner(board);
                if (winner) {
                    const prefix = piUser ? `@${piUser} - ` : '';
                    statusDiv.textContent = `${prefix}AI (${aiPlayer}) Wins!`;
                    gameActive = false;
                    highlightWin();
                    boardDiv.querySelectorAll('.cell').forEach(c => c.classList.add('disabled'));
                    submitBtn.style.display = 'none';
                    undoBtn.style.display = 'none';
                    return;
                }

                if (isBoardFull(board)) {
                    const prefix = piUser ? `@${piUser} - ` : '';
                    statusDiv.textContent = `${prefix}It's a Draw!`;
                    gameActive = false;
                    boardDiv.querySelectorAll('.cell').forEach(c => c.classList.add('disabled'));
                    submitBtn.style.display = 'none';
                    undoBtn.style.display = 'none';
                    return;
                }

                currentPlayer = humanPlayer;
                updateStatus();
                boardDiv.querySelectorAll('.cell').forEach(cell => cell.classList.remove('ai-thinking'));
                undoBtn.style.display = 'inline-block'; // Keep undo button displayed until player moves or timeout
                
                clearTimeout(aiTimeoutId);
                aiTimeoutId = setTimeout(() => {
                    aiTimeoutId = null;
                    undoBtn.style.display = 'none';
                }, 1500);
            }, 420 + Math.random() * 480);
        }

        function updateStatus() {
            const prefix = piUser ? `@${piUser} - ` : '';
            if (gameMode !== 'hotseat' && currentPlayer === aiPlayer) {
                statusDiv.textContent = prefix + "ü§ñ AI's Turn";
            } else {
                statusDiv.textContent = prefix + `Player ${currentPlayer}'s Turn`;
            }
        }

        // ===== Board init & render =====
        function initBoard() {
            boardDiv.innerHTML = '';
            board = new Array(boardSize).fill(null);
            history = [];
            for (let i = 0; i < boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.setAttribute('role','button');
                cell.setAttribute('aria-label', `Cell ${i+1}`);
                cell.addEventListener('click', handleCellClick);
                boardDiv.appendChild(cell);
            }
            boardDiv.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('x','o','won','ai-thinking','disabled');
                c.textContent = '';
            });
        }

        // ===== Click handler (hotseat vs AI differ) =====
        function handleCellClick(e) {
            if (!gameActive) return;
            const index = parseInt(e.currentTarget.dataset.index, 10);
            if (isNaN(index)) return;
            if (board[index] != null) return;
            // For hotseat allow both players; for AI modes only allow human's turn
            if (gameMode !== 'hotseat' && currentPlayer !== humanPlayer) return;

            // Place move
            board[index] = currentPlayer;
            const cell = e.currentTarget;
            cell.textContent = currentPlayer;
            cell.classList.add(currentPlayer.toLowerCase());
            history.push({ index, player: currentPlayer });

            const winner = checkWinner(board);
            if (winner) {
                const prefix = piUser ? `@${piUser} - ` : '';
                statusDiv.textContent = `${prefix}Player ${currentPlayer} Wins!`;
                gameActive = false;
                highlightWin();
                boardDiv.querySelectorAll('.cell').forEach(c => c.classList.add('disabled'));

                // Save local stats and enable submit for paid LB when applicable
                if (winner === humanPlayer) {
                    saveWin(); // Update personal wins/score stats
                    if (piUser && db) submitBtn.style.display = 'inline-block';
                } else {
                    submitBtn.style.display = 'none';
                }
                undoBtn.style.display = 'none';
                return;
            }

            if (isBoardFull(board)) {
                statusDiv.textContent = `It's a Draw!`;
                gameActive = false;
                boardDiv.querySelectorAll('.cell').forEach(c => c.classList.add('disabled'));
                undoBtn.style.display = 'none';
                submitBtn.style.display = 'none';
                return;
            }

            // Switch players
            if (gameMode === 'hotseat') {
                currentPlayer = (currentPlayer === 'X') ? 'O' : 'X';
                updateStatus();
            } else {
                // Human just moved vs AI ‚Äî give a short undo window then AI moves
                currentPlayer = aiPlayer;
                updateStatus();
                // reveal undo button temporarily (player can undo by paying)
                undoBtn.style.display = 'inline-block';
                if (aiTimeoutId) {
                    clearTimeout(aiTimeoutId);
                    aiTimeoutId = null;
                }
                aiTimeoutId = setTimeout(() => {
                    aiTimeoutId = null;
                    undoBtn.style.display = 'none';
                    if (gameActive && currentPlayer === aiPlayer) aiMove();
                }, 1500);
            }
        }

        // ===== Highlight winning line =====
        function highlightWin() {
            const winner = checkWinner(board);
            if (!winner) return;
            for (let cond of winningConditions) {
                const first = board[cond[0]];
                if (first === winner && cond.every(i => board[i] === winner)) {
                    cond.forEach(i => {
                        const cell = document.querySelector(`[data-index="${i}"]`);
                        if (cell) cell.classList.add('won');
                    });
                    return;
                }
            }
        }

        // ===== Undo logic (called after successful payment) =====
        function doUndo() {
            if (history.length === 0) return;
            const lastMove = history.pop();
            board[lastMove.index] = null;
            const cell = document.querySelector(`[data-index="${lastMove.index}"]`);
            if (cell) {
                cell.textContent = '';
                cell.classList.remove('x','o','won');
            }
            // restore game state: after undo we set currentPlayer to the player who just moved (so they can replay)
            currentPlayer = lastMove.player;
            gameActive = true;
            updateStatus();
            undoBtn.style.display = 'none';
            if (aiTimeoutId) { clearTimeout(aiTimeoutId); aiTimeoutId = null; }
            submitBtn.style.display = 'none';
            boardDiv.querySelectorAll('.cell').forEach(c => c.classList.remove('disabled'));

            // If it was the AI's turn when the undo was performed, let it move again
            if (currentPlayer === aiPlayer && gameMode !== 'hotseat') {
                clearTimeout(aiTimeoutId);
                aiTimeoutId = setTimeout(aiMove, 350);
            }
        }

        // ===== Payment wrapper (Pi) =====
        async function payForAction(action) {
            if (!piUser || typeof window.Pi === 'undefined' || !window.Pi.createPayment) {
                alert('Connect Pi and run inside Pi Browser to pay.');
                return false;
            }
            if (!history.length && action === 'undo') return false;

            try {
                const paymentData = {
                    amount: 1,
                    memo: `Pi Tic Tac Toe: ${action === 'undo' ? 'Undo Move' : 'Submit Win to LB'}`,
                    metadata: { user: piUser, game: 'tictactoe', action }
                };
                const paymentCallbacks = {
                    onReadyForServerApproval: (paymentId) => { console.log('ready for approval', paymentId); },
                    onReadyForServerCompletion: (paymentId, txid) => { console.log('ready for completion', paymentId, txid); },
                    onPaymentSuccess: (payment, txid) => {
                        console.log('payment success', action, payment, txid);
                        if (action === 'undo') doUndo();
                        else if (action === 'submit') submitToLB();
                    },
                    onCancel: () => console.log('payment canceled'),
                    onError: (err) => { console.error('payment error', err); alert('Payment error: ' + (err && err.message ? err.message : 'Unknown error')); }
                };
                await window.Pi.createPayment(paymentData, paymentCallbacks);
                return true;
            } catch (err) {
                console.error('payment init failed', err);
                alert('Payment failed to start. Try again in Pi Browser.');
                return false;
            }
        }

        // ===== Save win locally (Firebase RTDB 'stats' node for user's personal stats) =====
        function saveWin() {
            if (!piUser || !db) return;
            const score = scoreValues[gameMode] || 1;
            const ref = db.ref("stats/" + piUser);

            ref.once("value", snap => {
                const old = snap.val() || { score: 0, wins: 0 };
                ref.set({
                    score: old.score + score,
                    wins: old.wins + 1,
                    updated: Date.now()
                });
                updatePersonalStats(); // Refresh display
            });
        }
        
        // ===== Leaderboard submission (Firebase RTDB 'leaderboard' node for paid wins) / UI =====
        function submitToLB() {
            if (!db) { alert('Firebase not configured; cannot submit.'); return; }
            const diffScore = scoreValues[gameMode] || 1;
            db.ref('leaderboard').push({
                username: piUser || 'anon',
                score: diffScore,
                difficulty: gameMode,
                time: Date.now()
            }).then(() => {
                submitBtn.textContent = 'Submitted ‚úÖ';
                submitBtn.disabled = true;
                // updatePersonalStats(); // Already handled by saveWin() called on human win
                statusDiv.textContent += ' | Submitted to LB';
                setTimeout(() => {
                    submitBtn.style.display = 'none';
                    submitBtn.textContent = 'Submit Win to Exclusive LB - 1 Pi';
                    submitBtn.disabled = false;
                }, 2200);
            }).catch(e => alert('Submit failed: ' + (e && e.message ? e.message : e)));
        }

        async function showLeaderboard() {
            if (!db) { alert('Firebase config missing; leaderboard unavailable.'); return; }
            const scores = {};
            try {
                const snapshot = await db.ref('leaderboard').limitToLast(1000).once('value');
                snapshot.forEach(child => {
                    const data = child.val();
                    const user = data.username || 'anon';
                    scores[user] = (scores[user] || 0) + (data.score || 1);
                });
                const topScores = Object.entries(scores)
                    .sort(([,a],[,b]) => b - a)
                    .slice(0, 50)
                    .map(([user, score], idx) => ({ user, score, rank: idx + 1 }));
                const tbody = document.querySelector('#lb-table tbody');
                tbody.innerHTML = '';
                topScores.forEach(entry => {
                    const tr = document.createElement('tr');
                    tr.innerHTML = `<td>${entry.rank}.</td><td>@${entry.user}</td><td>${entry.score}</td>`;
                    tbody.appendChild(tr);
                });
                lbSection.style.display = 'flex';
            } catch (e) {
                alert('Leaderboard load failed: ' + (e && e.message ? e.message : e));
            }
        }

        // ===== Local stats =====
        function updatePersonalStats() {
            if (!db || !piUser) return;
            db.ref("stats/" + piUser).once("value", snap => {
                const d = snap.val();
                if (!d) {
                    personalStatsDiv.textContent = "No wins yet.";
                } else {
                    personalStatsDiv.textContent =
                        `Wins: ${d.wins} | Score: ${d.score}`;
                }
            });
        }
        
        function loadStats() {
            if (!db || !piUser) return;
            db.ref("stats/" + piUser).once("value", snap => {
                const d = snap.val();
                if (!d) {
                    personalStatsDiv.textContent = "No wins yet.";
                } else {
                    personalStatsDiv.textContent =
                        `Wins: ${d.wins} | Score: ${d.score}`;
                }
            });
        }


        // ===== Button Event Handlers (using consolidated functions) =====
        
        undoBtn.onclick = async () => {
            if (!piUser) return alert('Connect Pi Account to use paid features.');
            if (history.length === 0) return;
            await payForAction('undo');
        };

        submitBtn.onclick = async () => {
            if (!piUser) return alert('Connect Pi Account to use paid features.');
            await payForAction('submit');
        };

        lbBtn.onclick = showLeaderboard;

        // ===== Connect Pi =====
        connectBtn.onclick = async () => {
            if (!Pi || !Pi.authenticate) {
                alert("Pi Browser required");
                return;
            }
            try {
                const user = await Pi.authenticate([], () => {});
                piUser = user.username;
                addressDiv.textContent = "@" + piUser;
                statsSection.style.display = "block";
                loadStats();
            } catch (e) {
                console.error(e);
            }
        };


        // ===== Reset (New Game) =====
        resetBtn.onclick = () => {
            gameActive = true;
            currentPlayer = humanPlayer;
            submitBtn.style.display = 'none';
            undoBtn.style.display = 'none';
            clearTimeout(aiTimeoutId);
            updateMode();
        };

        // ===== Mode change =====
        modeSelect.onchange = () => {
            updateMode();
        };

        function updateMode() {
            gameMode = modeSelect.value;

            if (gameMode === "unbeatable") N = 5;
            else N = 3;

            boardSize = N * N;
            document.documentElement.style.setProperty('--n', N);
            winningConditions = generateWinningConditions(N);
            initBoard();
            updateStatus();
            
            // If the new mode is AI and it's AI's first turn (e.g., after hotseat), start AI move
            if (gameMode !== 'hotseat' && currentPlayer === aiPlayer) {
                 clearTimeout(aiTimeoutId); // Clear any pending AI move from a previous game
                 aiTimeoutId = setTimeout(aiMove, 350);
            }
        }

        // ===== Init =====
        updateMode();
    </script>
</body>
</html>
